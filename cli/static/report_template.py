"""
ContestTrade Final Report Template
æœ€ç»ˆæŠ¥å‘Šæ¨¡æ¿ç”Ÿæˆå™¨
"""
import os
from datetime import datetime
from pathlib import Path
from typing import Dict, List
from rich.console import Console
from rich.panel import Panel
from rich.text import Text
from rich.table import Table
from rich.markdown import Markdown
from rich.layout import Layout
from rich.live import Live
from rich.align import Align
from rich import box
import re

# Use the new Markdownâ†’HTMLâ†’PDF exporter
try:
    from ..export.md_to_pdf import export_markdown_to_pdf
except Exception:
    export_markdown_to_pdf = None

# Extra CSS for data_report only: increase nested list indent
DATA_REPORT_EXTRA_CSS = (
    ".markdown-body li > ul, .markdown-body li > ol { margin-left: 2.2em; }\n"
    ".markdown-body ul ul, .markdown-body ol ol { margin-left: 2.0em; }\n"
    ".markdown-body ol > li > ul, .markdown-body ul > li > ol { margin-left: 2.2em; }\n"
)

class DataReportGenerator:
    """æ•°æ®æŠ¥å‘Šç”Ÿæˆå™¨"""
    
    def __init__(self, factors_data: Dict):
        self.factors_data = factors_data
        self.console = Console()
        self.market_type = os.environ.get('CONTEST_TRADE_MARKET', 'CN-Stock')
        
    def get_text(self, cn_text: str, en_text: str) -> str:
        return en_text if self.market_type == 'US-Stock' else cn_text
        
    def generate_markdown_report(self, save_path: Path) -> str:
        """ç”Ÿæˆæ•°æ®æŠ¥å‘Šçš„Markdownæ ¼å¼"""
        
        # è·å–è§¦å‘æ—¶é—´
        trigger_time = self.factors_data.get('trigger_time', 'N/A')
        
        # ç»Ÿè®¡æ•°æ®æºæ•°é‡å’Œä»£ç†æ•°é‡
        total_agents = len(self.factors_data.get('agents', {}))
        
        report_content = f"""# ContestTrade {self.get_text('æ•°æ®åˆ†ææŠ¥å‘Š', 'Data Analysis Report')}

## ğŸ“Š {self.get_text('æ•°æ®æ‘˜è¦', 'Data Summary')}

**{self.get_text('åˆ†ææ—¶é—´', 'Analysis Time')}**: {trigger_time}  
**{self.get_text('åˆ†æçŠ¶æ€', 'Analysis Status')}**: âœ… {self.get_text('å®Œæˆ', 'Completed')}  
**{self.get_text('æ•°æ®ä»£ç†æ•°é‡', 'Data Agent Count')}**: {total_agents}  

---

## ğŸ” {self.get_text('æ•°æ®æºåˆ†æè¯¦æƒ…', 'Data Source Analysis Details')}

"""
        
        # éå†æ¯ä¸ªä»£ç†çš„æ•°æ®
        for agent_name, agent_data in self.factors_data.get('agents', {}).items():
            report_content += f"### ğŸ“ˆ {agent_name.replace('_', ' ').title()}\n\n"
            
            # åªè·å–context_stringå­—æ®µ
            context_string = agent_data.get('context_string', '')
            
            if context_string:
                # æ¸…æ´—æ‰ [Batch X] æ ‡è®°
                cleaned_context = re.sub(r'\[Batch \d+\]', '', context_string).strip()
                report_content += f"{cleaned_context}\n\n"
            else:
                report_content += f"**{self.get_text('æš‚æ— åˆ†æå†…å®¹', 'No analysis content available')}**\n\n"
            
            report_content += "---\n\n"
        
        # å…è´£å£°æ˜
        report_content += f"## âš ï¸ {self.get_text('å…è´£å£°æ˜', 'Disclaimer')}\n\n"
        report_content += self.get_text("æœ¬æŠ¥å‘Šç”±ContestTradeæ•°æ®åˆ†æç³»ç»Ÿç”Ÿæˆï¼Œæ•°æ®æ¥æºäºå„ä¸ªæ•°æ®ä»£ç†çš„åˆ†æç»“æœï¼Œä»…ä¾›å‚è€ƒã€‚\n\n", "This report is generated by the ContestTrade data analysis system. The data comes from the analysis results of various data agents and is for reference only.\n\n")
        report_content += f"**{self.get_text('æŠ¥å‘Šç”Ÿæˆæ—¶é—´', 'Report Generation Time')}**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        report_content += f"**{self.get_text('ç³»ç»Ÿç‰ˆæœ¬', 'System Version')}**: ContestTrade v1.1.0\n"
        
        # ä¿å­˜åˆ°æ–‡ä»¶
        with open(save_path, 'w', encoding='utf-8') as f:
            f.write(report_content)
        
        return report_content
    
    def display_terminal_interactive_report(self, markdown_content: str):
        """æ˜¾ç¤ºå¯æ»šåŠ¨çš„äº¤äº’å¼ç»ˆç«¯æ•°æ®æŠ¥å‘Š"""
        
        # åˆ›å»ºRichæ§åˆ¶å°ï¼Œå¯ç”¨å¯æ»šåŠ¨åŠŸèƒ½
        console = Console()
        
        # åˆ›å»ºMarkdownå¯¹è±¡
        markdown = Markdown(markdown_content)
        
        # åˆ›å»ºé¢æ¿
        report_panel = Panel(
            markdown,
            title=f"ğŸ“‹ ContestTrade {self.get_text('æ•°æ®åˆ†ææŠ¥å‘Š', 'Data Analysis Report')}",
            title_align="center",
            border_style="blue",
            padding=(1, 2),
        )
        
        # æ¸…å±å¹¶æ˜¾ç¤ºæŠ¥å‘Š
        console.clear()
        console.print(report_panel)
        
        # æ“ä½œæç¤º
        console.print(f"\n[yellow]ğŸ“– {self.get_text('æŠ¥å‘ŠæŸ¥çœ‹è¯´æ˜', 'Report Viewing Instructions')}:[/yellow]")
        console.print(f"[dim]â€¢ {self.get_text('å‘ä¸Šæ»šåŠ¨æŸ¥çœ‹æŠ¥å‘Šå¼€å¤´å†…å®¹', 'Scroll up to view the beginning of the report')}[/dim]")
        console.print(f"[dim]â€¢ {self.get_text('å‘ä¸‹æ»šåŠ¨æŸ¥çœ‹æ›´å¤šè¯¦ç»†ä¿¡æ¯', 'Scroll down to view more details')}[/dim]") 
        console.print(f"[dim]â€¢ {self.get_text('æŒ‰ä»»æ„é”®è¿”å›ä¸»èœå•', 'Press any key to return to main menu')}[/dim]")
        
        try:
            input()
        except KeyboardInterrupt:
            pass
    
    def display_interactive_report(self, markdown_content: str, save_path: Path):
        """æ˜¾ç¤ºå¯æ»šåŠ¨çš„äº¤äº’å¼æ•°æ®æŠ¥å‘Š"""
        
        # åˆ›å»ºRichæ§åˆ¶å°ï¼Œå¯ç”¨å¯æ»šåŠ¨åŠŸèƒ½
        console = Console()
        
        # åˆ›å»ºMarkdownå¯¹è±¡
        markdown = Markdown(markdown_content)
        
        report_panel = Panel(
            markdown,
            title="ğŸ“‹ ContestTrade Data Report",
            title_align="center",
            border_style="blue",
            padding=(1, 2),
        )
        
        # æ¸…å±å¹¶æ˜¾ç¤ºæŠ¥å‘Š
        console.clear()
        console.print(report_panel)
        
        # æ˜¾ç¤ºæ–‡ä»¶ä¿å­˜ä¿¡æ¯å’Œæ“ä½œæç¤º
        console.print(f"\n[green]âœ… {self.get_text('æ•°æ®æŠ¥å‘Šå·²ä¿å­˜è‡³', 'Data report saved to')}:[/green]")
        console.print(f"[blue]ğŸ“„ {save_path}[/blue]")
        console.print(f"[dim]{self.get_text('æ‚¨å¯ä»¥ä½¿ç”¨æ–‡æœ¬ç¼–è¾‘å™¨æ‰“å¼€æŸ¥çœ‹å®Œæ•´æŠ¥å‘Š', 'You can open it with a text editor to view the full report')}[/dim]")
        
        # æ“ä½œæç¤º
        console.print(f"\n[yellow]ğŸ“– {self.get_text('æŠ¥å‘Šæ“ä½œè¯´æ˜', 'Report Operation Instructions')}:[/yellow]")
        console.print(f"[dim]â€¢ {self.get_text('å‘ä¸Šæ»šåŠ¨æŸ¥çœ‹æŠ¥å‘Šå¼€å¤´', 'Scroll up to view the beginning of the report')}[/dim]")
        console.print(f"[dim]â€¢ {self.get_text('å‘ä¸‹æ»šåŠ¨æŸ¥çœ‹æ›´å¤šå†…å®¹', 'Scroll down to view more content')}[/dim]") 
        console.print(f"[dim]â€¢ {self.get_text('æŒ‰ä»»æ„é”®è¿”å›ä¸»èœå•', 'Press any key to return to main menu')}[/dim]")
        
        try:
            input()
        except KeyboardInterrupt:
            pass


class FinalReportGenerator:
    """æœ€ç»ˆæŠ¥å‘Šç”Ÿæˆå™¨"""
    
    def __init__(self, final_state: Dict):
        self.final_state = final_state
        self.console = Console()
        self.market_type = os.environ.get('CONTEST_TRADE_MARKET', 'CN-Stock')
        
    def get_text(self, cn_text: str, en_text: str) -> str:
        return en_text if self.market_type == 'US-Stock' else cn_text
        
    def get_agent_name(self, agent_id: str) -> str:
        """è·å–Agentåç§°"""
        agent_name = f"agent {agent_id}"
        try:
            # å°è¯•ä»final_stateä¸­è·å–agentåç§°
            if hasattr(self, 'final_state') and self.final_state:
                step_results = self.final_state.get('step_results', {})
                research_agents = step_results.get('research_agents', {})
                if agent_id in research_agents:
                    agent_config = research_agents[agent_id].get('config', {})
                    if agent_config and 'agent_name' in agent_config:
                        agent_name = agent_config['agent_name']
        except:
            # å¦‚æœè·å–å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤æ ¼å¼
            agent_name = f"agent {agent_id}"
        return agent_name
        
    def generate_markdown_report(self, save_path: Path) -> str:
        """ç”ŸæˆMarkdownæ ¼å¼çš„æŠ¥å‘Š"""
        
        # è·å–åŸºæœ¬ä¿¡æ¯
        step_results = self.final_state.get('step_results', {})
        data_team_results = step_results.get('data_team', {})
        research_team_results = step_results.get('research_team', {})
        contest_results = step_results.get('contest', {})
        
        # è·å–è§¦å‘æ—¶é—´ï¼Œç¡®ä¿æ­£ç¡®è§£æ
        trigger_time = self.final_state.get('trigger_time', 'N/A')
        if trigger_time == 'N/A':
            # å°è¯•ä»å…¶ä»–åœ°æ–¹è·å–æ—¶é—´
            trigger_time = step_results.get('trigger_time', 'N/A')
        
        data_factors_count = data_team_results.get('factors_count', 0)
        research_signals_count = research_team_results.get('signals_count', 0)
        best_signals = contest_results.get('best_signals', [])
        
        # ç­›é€‰æœ‰æ•ˆä¿¡å·
        valid_signals = [s for s in best_signals if s.get('has_opportunity', 'no') == 'yes']
        invalid_signals = [s for s in best_signals if s.get('has_opportunity', 'no') != 'yes']
        
        # ç”ŸæˆæŠ¥å‘Šå†…å®¹
        signal_rate = f"{len(valid_signals)/len(best_signals)*100:.1f}% ({len(valid_signals)}/{len(best_signals)})" if len(best_signals) > 0 else "0% (0/0)"
        
        report_content = f"""# ContestTrade {self.get_text('æœ€ç»ˆåˆ†ææŠ¥å‘Š', 'Final Analysis Report')}

## ğŸ“Š {self.get_text('æ‰§è¡Œæ‘˜è¦', 'Executive Summary')}

**{self.get_text('åˆ†ææ—¶é—´', 'Analysis Time')}**: {trigger_time}  
**{self.get_text('åˆ†æçŠ¶æ€', 'Analysis Status')}**: âœ… {self.get_text('å®Œæˆ', 'Completed')}  
**{self.get_text('æ•°æ®æºæ•°é‡', 'Data Sources Count')}**: {data_factors_count}  
**{self.get_text('ç ”ç©¶ä¿¡å·æ•°é‡', 'Research Signals Count')}**: {research_signals_count}  
**{self.get_text('æœ‰æ•ˆæŠ•èµ„ä¿¡å·', 'Valid Investment Signals')}**: {len(valid_signals)}  
**{self.get_text('ä¿¡å·æœ‰æ•ˆç‡', 'Signal Effectiveness Rate')}**: {signal_rate}

---

## ğŸ¯ {self.get_text('æŠ•èµ„å»ºè®®æ‘˜è¦', 'Investment Recommendations Summary')}

"""
        
        if valid_signals:
            report_content += f"### âœ… {self.get_text('æ¨èæŠ•èµ„ä¿¡å·', 'Recommended Investment Signals')} ({len(valid_signals)}{self.get_text('ä¸ª', '')})\n\n"
            
            for i, signal in enumerate(valid_signals, 1):
                symbol_name = signal.get('symbol_name', 'N/A')
                symbol_code = signal.get('symbol_code', 'N/A')
                action = signal.get('action', 'N/A')
                agent_id = signal.get('agent_id', 'N/A')
                
                report_content += f"#### {i}. {symbol_name} ({symbol_code})\n\n"
                report_content += f"- **{self.get_text('æŠ•èµ„åŠ¨ä½œ', 'Investment Action')}**: {action}\n"
                
                # ä½¿ç”¨é‡æ„çš„å‡½æ•°è·å–agentåç§°
                agent_name = self.get_agent_name(agent_id)
                report_content += f"- **{self.get_text('åˆ†ææ¥æº', 'Analysis Source')}**: {agent_name}\n"
                
                # è¯æ®è¯¦æƒ…
                evidence_list = signal.get('evidence_list', [])
                if evidence_list:
                    report_content += f"- **{self.get_text('æ”¯æ’‘è¯æ®', 'Supporting Evidence')}** ({len(evidence_list)}{self.get_text('é¡¹', '')}):\n"
                    for j, evidence in enumerate(evidence_list, 1):
                        desc = evidence.get('description', 'N/A')
                        source = evidence.get('from_source', 'N/A')
                        time = evidence.get('time', 'N/A')
                        report_content += f"    {j}. **{desc}** ({self.get_text('æ¥æº', 'Source')}: {source}, {self.get_text('æ—¶é—´', 'Time')}: {time})\n"
                
                # é£é™©æç¤º
                limitations = signal.get('limitations', [])
                if limitations:
                    report_content += f"- **{self.get_text('é£é™©æç¤º', 'Risk Warnings')}**:\n"
                    for limitation in limitations:
                        report_content += f"    - {limitation}\n"
                
                report_content += "\n"
        else:
            report_content += f"### âŒ {self.get_text('æš‚æ— æ¨èæŠ•èµ„ä¿¡å·', 'No Recommended Investment Signals')}\n\n"
            report_content += self.get_text("æœ¬æ¬¡åˆ†ææœªå‘ç°å…·æœ‰æ˜ç¡®æŠ•èµ„æœºä¼šçš„ä¿¡å·ã€‚\n\n", "No signals with clear investment opportunities were found in this analysis.\n\n")
        
        # æ— æ•ˆä¿¡å·ç»Ÿè®¡
        if invalid_signals:
            report_content += f"### âš ï¸ {self.get_text('æ’é™¤ä¿¡å·', 'Excluded Signals')} ({len(invalid_signals)}{self.get_text('ä¸ª', '')})\n\n"
            report_content += self.get_text("ä»¥ä¸‹ä¿¡å·ç»åˆ†æåè®¤ä¸ºä¸å…·å¤‡æŠ•èµ„æœºä¼šï¼š\n\n", "The following signals were analyzed and deemed not to have investment opportunities:\n\n")
            
            for i, signal in enumerate(invalid_signals, 1):
                agent_id = signal.get('agent_id', 'N/A')
                
                # ä½¿ç”¨é‡æ„çš„å‡½æ•°è·å–agentåç§°
                agent_name = self.get_agent_name(agent_id)
                report_content += f"{i}. {agent_name} - {self.get_text('æ— æ˜ç¡®æŠ•èµ„æœºä¼š', 'No clear investment opportunity')}\n"
            
            report_content += "\n"
        
        # å…è´£å£°æ˜
        report_content += "---\n\n## âš ï¸ {self.get_text('å…è´£å£°æ˜', 'Disclaimer')}\n\n"
        report_content += self.get_text("æœ¬æŠ¥å‘Šç”±ContestTrade AIç³»ç»Ÿç”Ÿæˆï¼Œä»…ä¾›å‚è€ƒï¼Œä¸æ„æˆæŠ•èµ„å»ºè®®ã€‚æŠ•èµ„æœ‰é£é™©ï¼Œå†³ç­–éœ€è°¨æ…ã€‚\n\n", "This report is generated by the ContestTrade AI system and is for reference only. It does not constitute investment advice. Investing involves risks, and decisions should be made carefully.\n\n")
        report_content += f"**{self.get_text('æŠ¥å‘Šç”Ÿæˆæ—¶é—´', 'Report Generation Time')}**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        report_content += f"**{self.get_text('ç³»ç»Ÿç‰ˆæœ¬', 'System Version')}**: ContestTrade v1.0.0\n"
        
        # ä¿å­˜åˆ°æ–‡ä»¶
        with open(save_path, 'w', encoding='utf-8') as f:
            f.write(report_content)
        
        return report_content
    
    def display_terminal_interactive_report(self, markdown_content: str):
        """æ˜¾ç¤ºå¯æ»šåŠ¨çš„äº¤äº’å¼ç»ˆç«¯æŠ¥å‘Šï¼ˆä¸ä¿å­˜æ–‡ä»¶ï¼‰"""
        
        # åˆ›å»ºRichæ§åˆ¶å°ï¼Œå¯ç”¨å¯æ»šåŠ¨åŠŸèƒ½
        console = Console()
        
        # åˆ›å»ºMarkdownå¯¹è±¡
        markdown = Markdown(markdown_content)
        
        # åˆ›å»ºé¢æ¿
        report_panel = Panel(
            markdown,
            title=f"ğŸ“‹ ContestTrade {self.get_text('è¯¦ç»†åˆ†ææŠ¥å‘Š', 'Detailed Analysis Report')}",
            title_align="center",
            border_style="blue",
            padding=(1, 2),
        )
        
        # æ¸…å±å¹¶æ˜¾ç¤ºæŠ¥å‘Š
        console.clear()
        console.print(report_panel)
        
        # æ“ä½œæç¤º
        console.print(f"\n[yellow]ğŸ“– {self.get_text('æŠ¥å‘ŠæŸ¥çœ‹è¯´æ˜', 'Report Viewing Instructions')}:[/yellow]")
        console.print(f"[dim]â€¢ {self.get_text('å‘ä¸Šæ»šåŠ¨æŸ¥çœ‹æŠ¥å‘Šå¼€å¤´å†…å®¹', 'Scroll up to view the beginning of the report')}[/dim]")
        console.print(f"[dim]â€¢ {self.get_text('å‘ä¸‹æ»šåŠ¨æŸ¥çœ‹æ›´å¤šè¯¦ç»†ä¿¡æ¯', 'Scroll down to view more details')}[/dim]") 
        console.print(f"[dim]â€¢ {self.get_text('æŒ‰ä»»æ„é”®è¿”å›ä¸»èœå•', 'Press any key to return to main menu')}[/dim]")
        
        try:
            input()
        except KeyboardInterrupt:
            pass
    
    def display_interactive_report(self, markdown_content: str, save_path: Path):
        """æ˜¾ç¤ºå¯æ»šåŠ¨çš„äº¤äº’å¼æŠ¥å‘Š"""
        
        # åˆ›å»ºRichæ§åˆ¶å°ï¼Œå¯ç”¨å¯æ»šåŠ¨åŠŸèƒ½
        console = Console()
        
        # åˆ›å»ºMarkdownå¯¹è±¡
        markdown = Markdown(markdown_content)
        
        report_panel = Panel(
            markdown,
            title="ğŸ“‹ ContestTrade Final Report",
            title_align="center",
            border_style="blue",
            padding=(1, 2),
        )
        
        # æ¸…å±å¹¶æ˜¾ç¤ºæŠ¥å‘Š
        console.clear()
        console.print(report_panel)
        
        # æ˜¾ç¤ºæ–‡ä»¶ä¿å­˜ä¿¡æ¯å’Œæ“ä½œæç¤º
        console.print(f"\n[green]âœ… {self.get_text('æŠ¥å‘Šå·²ä¿å­˜è‡³', 'Report saved to')}:[/green]")
        console.print(f"[blue]ğŸ“„ {save_path}[/blue]")
        console.print(f"[dim]{self.get_text('æ‚¨å¯ä»¥ä½¿ç”¨æ–‡æœ¬ç¼–è¾‘å™¨æ‰“å¼€æŸ¥çœ‹å®Œæ•´æŠ¥å‘Š', 'You can open it with a text editor to view the full report')}[/dim]")
        
        # æ“ä½œæç¤º
        console.print(f"\n[yellow]ğŸ“– {self.get_text('æŠ¥å‘Šæ“ä½œè¯´æ˜', 'Report Operation Instructions')}:[/yellow]")
        console.print(f"[dim]â€¢ {self.get_text('å‘ä¸Šæ»šåŠ¨æŸ¥çœ‹æŠ¥å‘Šå¼€å¤´', 'Scroll up to view the beginning of the report')}[/dim]")
        console.print(f"[dim]â€¢ {self.get_text('å‘ä¸‹æ»šåŠ¨æŸ¥çœ‹æ›´å¤šå†…å®¹', 'Scroll down to view more content')}[/dim]") 
        console.print(f"[dim]â€¢ {self.get_text('æŒ‰ä»»æ„é”®è¿”å›ä¸»èœå•', 'Press any key to return to main menu')}[/dim]")
        
        try:
            input()
        except KeyboardInterrupt:
            pass
    
    def create_summary_table(self) -> Table:
        """åˆ›å»ºæ‘˜è¦è¡¨æ ¼"""
        table = Table(title=self.get_text("æŠ•èµ„ä¿¡å·æ‘˜è¦", "Investment Signals Summary"), box=box.ROUNDED)
        
        table.add_column(self.get_text("åºå·", "No."), style="cyan", no_wrap=True)
        table.add_column(self.get_text("è‚¡ç¥¨åç§°", "Stock Name"), style="magenta")
        table.add_column(self.get_text("è‚¡ç¥¨ä»£ç ", "Stock Code"), style="magenta")
        table.add_column(self.get_text("æŠ•èµ„åŠ¨ä½œ", "Investment Action"), style="green")
        table.add_column(self.get_text("åˆ†ææ¥æº", "Analysis Source"), style="blue")
        table.add_column(self.get_text("çŠ¶æ€", "Status"), style="yellow")
        
        step_results = self.final_state.get('step_results', {})
        best_signals = step_results.get('contest', {}).get('best_signals', [])
        
        for i, signal in enumerate(best_signals, 1):
            symbol_name = signal.get('symbol_name', 'N/A')
            symbol_code = signal.get('symbol_code', 'N/A')
            action = signal.get('action', 'N/A')
            agent_id = signal.get('agent_id', 'N/A')
            has_opportunity = signal.get('has_opportunity', 'no')
            
            status = self.get_text("âœ… æ¨è", "âœ… Recommended") if has_opportunity == 'yes' else self.get_text("âŒ æ’é™¤", "âŒ Excluded")
            
            # ä½¿ç”¨é‡æ„çš„å‡½æ•°è·å–agentåç§°
            agent_display_name = self.get_agent_name(agent_id)
            
            table.add_row(
                str(i),
                symbol_name,
                symbol_code,
                action,
                agent_display_name,
                status
            )
        
        return table

def _write_pdf_from_text(text: str, pdf_path: Path, *, extra_css: str | None = None, normalize_ol_sublist: bool = False):
    """Legacy shim retained for compatibility; now delegates to HTML renderer.

    For better fidelity, we convert Markdown text to HTML using the new
    `export_markdown_to_pdf` path by writing a temporary markdown next to
    the desired PDF and producing a same-stem PDF.
    """
    try:
        if export_markdown_to_pdf is None:
            # If exporter not available, skip silently
            return
        tmp_md = pdf_path.with_suffix('.md')
        tmp_md.write_text(text, encoding='utf-8')
        export_markdown_to_pdf(
            tmp_md,
            output_dir=pdf_path.parent,
            html_filename=f"{pdf_path.stem}.html",
            pdf_filename=pdf_path.name,
            title="ContestTrade Report",
            extra_css=extra_css,
            normalize_ol_sublist=normalize_ol_sublist,
        )
        # Optionally remove the temporary markdown if it wasn't originally requested
        try:
            tmp_md.unlink(missing_ok=True)
        except Exception:
            pass
    except Exception:
        pass


def generate_data_report(factors_data: Dict, results_dir: Path) -> tuple[str, Path]:
    """ç”Ÿæˆæ•°æ®æŠ¥å‘Š"""
    
    # åˆ›å»ºæ•°æ®æŠ¥å‘Šç”Ÿæˆå™¨
    generator = DataReportGenerator(factors_data)
    
    # ç”Ÿæˆæ–‡ä»¶å
    trigger_time = factors_data.get('trigger_time', 'N/A')
    
    if trigger_time != 'N/A' and trigger_time is not None:
        safe_time = trigger_time.replace(' ', '_').replace(':', '-')
    else:
        safe_time = datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
    
    # Directories
    markdown_dir = results_dir / "markdown"
    pdf_dir = results_dir / "pdf"
    markdown_dir.mkdir(parents=True, exist_ok=True)
    pdf_dir.mkdir(parents=True, exist_ok=True)

    md_path = markdown_dir / f"data_report_{safe_time}.md"
    markdown_content = generator.generate_markdown_report(md_path)

    # Also export PDF
    pdf_path = pdf_dir / f"data_report_{safe_time}.pdf"
    # Increase nested list indent specifically for data report
    _write_pdf_from_text(
        markdown_content,
        pdf_path,
        extra_css=DATA_REPORT_EXTRA_CSS,
        normalize_ol_sublist=True,
    )

    return markdown_content, md_path


def display_data_report_interactive(factors_data: Dict, results_dir: Path):
    """æ˜¾ç¤ºäº¤äº’å¼æ•°æ®æŠ¥å‘Š"""
    
    markdown_content, save_path = generate_data_report(factors_data, results_dir)
    generator = DataReportGenerator(factors_data)
    generator.display_interactive_report(markdown_content, save_path)
    
    return save_path


def generate_final_report(final_state: Dict, results_dir: Path) -> tuple[str, Path]:
    """ç”Ÿæˆæœ€ç»ˆæŠ¥å‘Š"""
    
    # åˆ›å»ºæŠ¥å‘Šç”Ÿæˆå™¨
    generator = FinalReportGenerator(final_state)
    
    # ç”Ÿæˆæ–‡ä»¶å
    trigger_time = final_state.get('trigger_time', 'N/A')
    
    if trigger_time != 'N/A' and trigger_time is not None:
        safe_time = trigger_time.replace(' ', '_').replace(':', '-')
    
    # Directories
    markdown_dir = results_dir / "markdown"
    pdf_dir = results_dir / "pdf"
    markdown_dir.mkdir(parents=True, exist_ok=True)
    pdf_dir.mkdir(parents=True, exist_ok=True)

    md_path = markdown_dir / f"final_report_{safe_time}.md"
    markdown_content = generator.generate_markdown_report(md_path)

    pdf_path = pdf_dir / f"final_report_{safe_time}.pdf"
    # Keep final_report export format unchanged (no extra CSS)
    _write_pdf_from_text(markdown_content, pdf_path)

    return markdown_content, md_path


def display_final_report_interactive(final_state: Dict, results_dir: Path):
    """æ˜¾ç¤ºäº¤äº’å¼æœ€ç»ˆæŠ¥å‘Š"""

    markdown_content, save_path = generate_final_report(final_state, results_dir)
    generator = FinalReportGenerator(final_state)
    generator.display_interactive_report(markdown_content, save_path)
    
    return save_path
